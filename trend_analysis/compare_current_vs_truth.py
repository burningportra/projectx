#!/usr/bin/env python3

import pandas as pd
import numpy as np

def load_and_truncate_data():
    """Load both CSV files and truncate to the same time period"""
    
    # Load current results (generated by main.py)
    current_df = pd.read_csv('trend_analysis/confirmed_trend_starts.csv')
    current_df['date'] = pd.to_datetime(current_df['date'])
    
    # Load truth data
    truth_df = pd.read_csv('trend_analysis/confirmed_trend_starts_4h_truth.csv')
    truth_df.columns = ['trend_type', 'bar_index', 'date']  # Normalize column names
    truth_df['date'] = pd.to_datetime(truth_df['date'])
    
    # Find the latest date in truth data
    truth_max_date = truth_df['date'].max()
    truth_max_bar = truth_df['bar_index'].max()
    
    print(f"Truth data goes up to: {truth_max_date} (bar {truth_max_bar})")
    
    # Truncate current results to match truth timeframe
    current_truncated = current_df[current_df['date'] <= truth_max_date].copy()
    
    print(f"Original current results: {len(current_df)} entries")
    print(f"Truncated current results: {len(current_truncated)} entries")
    print(f"Truth data: {len(truth_df)} entries")
    
    return current_truncated, truth_df

def analyze_differences(current_df, truth_df):
    """Analyze the key differences between current and truth data"""
    print("\n=== DIFFERENCE ANALYSIS ===")
    
    # Get all unique bar indices from both datasets
    current_bars = set(current_df['bar_index'].unique())
    truth_bars = set(truth_df['bar_index'].unique())
    
    # Find differences
    current_only = current_bars - truth_bars
    truth_only = truth_bars - current_bars
    common_bars = current_bars & truth_bars
    
    print(f"Bars only in current (over-detected): {len(current_only)}")
    print(f"Bars only in truth (missed): {len(truth_only)}")
    print(f"Common bars: {len(common_bars)}")
    
    if current_only:
        print(f"\nOver-detected bars: {sorted(current_only)}")
    
    if truth_only:
        print(f"\nMissed bars: {sorted(truth_only)}")
    
    return current_only, truth_only, common_bars

def analyze_trend_type_mismatches(current_df, truth_df, common_bars):
    """Check for trend type mismatches on common bars"""
    print("\n=== TREND TYPE MISMATCHES ===")
    
    mismatches = []
    
    for bar_idx in common_bars:
        current_trends = current_df[current_df['bar_index'] == bar_idx]['trend_start_type'].tolist()
        truth_trends = truth_df[truth_df['bar_index'] == bar_idx]['trend_type'].tolist()
        
        # If different trend types at same bar
        if set(current_trends) != set(truth_trends):
            mismatches.append({
                'bar_index': bar_idx,
                'current': current_trends,
                'truth': truth_trends,
                'date': current_df[current_df['bar_index'] == bar_idx]['date'].iloc[0]
            })
    
    if mismatches:
        print(f"Found {len(mismatches)} trend type mismatches:")
        for mm in mismatches:
            print(f"  Bar {mm['bar_index']} ({mm['date']}): Current={mm['current']}, Truth={mm['truth']}")
    else:
        print("No trend type mismatches on common bars!")
    
    return mismatches

def analyze_early_detection_problems(current_df, truth_df):
    """Focus on early detection issues"""
    print("\n=== EARLY DETECTION ANALYSIS ===")
    
    # Check the first 50 bars where most issues seem to occur
    early_current = current_df[current_df['bar_index'] <= 50].sort_values('bar_index')
    early_truth = truth_df[truth_df['bar_index'] <= 50].sort_values('bar_index')
    
    print("First 20 current results:")
    for _, row in early_current.head(20).iterrows():
        print(f"  Bar {row['bar_index']}: {row['trend_start_type']} at {row['date']}")
    
    print("\nFirst 20 truth results:")
    for _, row in early_truth.head(20).iterrows():
        print(f"  Bar {row['bar_index']}: {row['trend_type']} at {row['date']}")

def analyze_consecutive_same_trends(current_df, truth_df):
    """Check for consecutive same trend types (should alternate)"""
    print("\n=== CONSECUTIVE SAME TRENDS ===")
    
    def find_consecutive(df, trend_col):
        consecutive = []
        prev_trend = None
        count = 0
        start_bar = None
        
        for _, row in df.sort_values('bar_index').iterrows():
            if row[trend_col] == prev_trend:
                count += 1
            else:
                if count > 1:
                    consecutive.append({
                        'trend_type': prev_trend, 
                        'count': count,
                        'start_bar': start_bar,
                        'end_bar': row['bar_index'] - 1
                    })
                prev_trend = row[trend_col]
                count = 1
                start_bar = row['bar_index']
        
        if count > 1:
            consecutive.append({
                'trend_type': prev_trend, 
                'count': count,
                'start_bar': start_bar,
                'end_bar': df['bar_index'].max()
            })
        
        return consecutive
    
    current_consecutive = find_consecutive(current_df, 'trend_start_type')
    truth_consecutive = find_consecutive(truth_df, 'trend_type')
    
    print("Current consecutive same trends:")
    for cons in current_consecutive:
        print(f"  {cons['count']} consecutive {cons['trend_type']}s (bars {cons['start_bar']}-{cons['end_bar']})")
    
    print("Truth consecutive same trends:")
    for cons in truth_consecutive:
        print(f"  {cons['count']} consecutive {cons['trend_type']}s (bars {cons['start_bar']}-{cons['end_bar']})")

def detailed_side_by_side_comparison(current_df, truth_df):
    """Show side-by-side comparison for easier analysis"""
    print("\n=== SIDE-BY-SIDE COMPARISON ===")
    
    # Merge on bar_index
    merged = pd.merge(
        current_df[['bar_index', 'trend_start_type', 'date']].rename(columns={'trend_start_type': 'current_trend'}),
        truth_df[['bar_index', 'trend_type', 'date']].rename(columns={'trend_type': 'truth_trend'}),
        on='bar_index',
        how='outer',
        suffixes=('_current', '_truth')
    ).sort_values('bar_index')
    
    # Show where they differ
    differences = merged[
        (merged['current_trend'].notna() & merged['truth_trend'].isna()) |
        (merged['current_trend'].isna() & merged['truth_trend'].notna()) |
        (merged['current_trend'] != merged['truth_trend'])
    ]
    
    print(f"Found {len(differences)} differences out of {len(merged)} total possible bars")
    print("\nFirst 30 differences:")
    for _, row in differences.head(30).iterrows():
        current_trend = row['current_trend'] if pd.notna(row['current_trend']) else "MISSING"
        truth_trend = row['truth_trend'] if pd.notna(row['truth_trend']) else "MISSING"
        date = row['date_current'] if pd.notna(row['date_current']) else row['date_truth']
        print(f"  Bar {row['bar_index']:3d}: Current={current_trend:9s} | Truth={truth_trend:9s} | {date}")

def main():
    print("=== CURRENT VS TRUTH COMPARISON ===")
    
    # Load and truncate data
    current_df, truth_df = load_and_truncate_data()
    
    # Analyze differences
    current_only, truth_only, common_bars = analyze_differences(current_df, truth_df)
    
    # Check trend type mismatches
    mismatches = analyze_trend_type_mismatches(current_df, truth_df, common_bars)
    
    # Analyze early detection problems
    analyze_early_detection_problems(current_df, truth_df)
    
    # Check for consecutive same trends
    analyze_consecutive_same_trends(current_df, truth_df)
    
    # Detailed side-by-side
    detailed_side_by_side_comparison(current_df, truth_df)
    
    print("\n=== SUMMARY ===")
    print(f"Current results (truncated): {len(current_df)}")
    print(f"Truth results: {len(truth_df)}")
    print(f"Over-detection: {len(current_only)} bars")
    print(f"Under-detection: {len(truth_only)} bars")
    print(f"Trend type mismatches: {len(mismatches)}")
    
    accuracy = len(common_bars) / len(truth_df) * 100 if len(truth_df) > 0 else 0
    print(f"Detection accuracy: {accuracy:.1f}%")

if __name__ == "__main__":
    main() 