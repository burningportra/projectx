"""
Improved Trend Detector

This module implements an improved trend detection algorithm based on
pure price action patterns identified through statistical analysis of labeled data.
"""

import pandas as pd
import numpy as np
from typing import List, Dict, Optional, Union, Tuple
import importlib.util
import sys
import os
import logging

logger = logging.getLogger(__name__)

class ImprovedTrendDetector:
    """
    Improved trend detector that uses pure price action patterns.
    
    This detector applies the algorithms generated by the TrendPatternAnalyzer
    to detect trend starts and ends in price data.
    """
    
    def __init__(self):
        """Initialize the detector"""
        self.detectors = {}
        self.required_features = [
            'bar_size', 'body_size', 'upper_wick', 'lower_wick',
            'is_bullish', 'is_bearish', 'higher_close', 'lower_close',
            'higher_high', 'lower_low', 'close_position',
            'upper_half_close', 'lower_half_close'
        ]
        
    def load_detector(self, trend_type: str, detector_file: str) -> bool:
        """
        Load a detector for a specific trend type.
        
        Args:
            trend_type: Type of trend to detect (e.g., 'uptrendStart')
            detector_file: Path to Python file with detector function
            
        Returns:
            True if detector was loaded successfully, False otherwise
        """
        try:
            # Load module from file
            module_name = f"detector_{trend_type}"
            spec = importlib.util.spec_from_file_location(module_name, detector_file)
            
            if not spec or not spec.loader:
                logger.error(f"Failed to load detector {trend_type} from {detector_file}")
                return False
                
            module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(module)
            
            # Get detector function
            function_name = f"detect_{trend_type.lower()}"
            if not hasattr(module, function_name):
                logger.error(f"Detector file {detector_file} does not contain function {function_name}")
                return False
                
            # Store detector function
            self.detectors[trend_type] = getattr(module, function_name)
            logger.info(f"Loaded detector for {trend_type} from {detector_file}")
            return True
            
        except Exception as e:
            logger.error(f"Error loading detector {trend_type} from {detector_file}: {str(e)}")
            return False
            
    def prepare_data(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Add required price action features to the data.
        
        Args:
            df: DataFrame with OHLC data
            
        Returns:
            DataFrame with added price action features
        """
        result = df.copy()
        
        # Calculate bar properties
        result['bar_size'] = result['high'] - result['low']
        result['body_size'] = abs(result['close'] - result['open'])
        result['upper_wick'] = result['high'] - np.maximum(result['open'], result['close'])
        result['lower_wick'] = np.minimum(result['open'], result['close']) - result['low']
        
        # Bar direction
        result['is_bullish'] = result['close'] > result['open']
        result['is_bearish'] = result['close'] < result['open']
        
        # Price relationships
        result['higher_close'] = result['close'] > result['close'].shift(1)
        result['lower_close'] = result['close'] < result['close'].shift(1)
        result['higher_high'] = result['high'] > result['high'].shift(1)
        result['lower_low'] = result['low'] < result['low'].shift(1)
        
        # Close position within bar
        result['close_position'] = (result['close'] - result['low']) / result['bar_size'].replace(0, np.nan)
        result['close_position'] = result['close_position'].fillna(0.5)
        result['upper_half_close'] = result['close_position'] > 0.5
        result['lower_half_close'] = result['close_position'] < 0.5
        
        # Significant wicks
        result['significant_upper_wick'] = result['upper_wick'] > (result['bar_size'] * 0.3)
        result['significant_lower_wick'] = result['lower_wick'] > (result['bar_size'] * 0.3)
        
        # Add candlestick patterns
        self._add_candlestick_patterns(result)
        
        return result
        
    def _add_candlestick_patterns(self, df: pd.DataFrame) -> None:
        """Add candlestick pattern recognition features."""
        # Engulfing patterns
        df['bullish_engulfing'] = (
            (df['is_bearish'].shift(1)) & 
            (df['is_bullish']) & 
            (df['open'] < df['close'].shift(1)) & 
            (df['close'] > df['open'].shift(1))
        )
        
        df['bearish_engulfing'] = (
            (df['is_bullish'].shift(1)) & 
            (df['is_bearish']) & 
            (df['open'] > df['close'].shift(1)) & 
            (df['close'] < df['open'].shift(1))
        )
        
        # Potential reversal patterns
        df['potential_bottom'] = False
        df['potential_top'] = False
        
        # Calculate consecutive patterns (requires loop)
        for i in range(3, len(df)):
            # Potential bottom pattern (3 bearish bars followed by bullish)
            if (df['is_bearish'].iloc[i-3] and
                df['is_bearish'].iloc[i-2] and
                df['is_bearish'].iloc[i-1] and
                df['is_bullish'].iloc[i]):
                df.loc[df.index[i], 'potential_bottom'] = True
                
            # Potential top pattern (3 bullish bars followed by bearish)
            if (df['is_bullish'].iloc[i-3] and
                df['is_bullish'].iloc[i-2] and
                df['is_bullish'].iloc[i-1] and
                df['is_bearish'].iloc[i]):
                df.loc[df.index[i], 'potential_top'] = True
        
        # Rejection patterns
        df['upper_rejection'] = (df['upper_wick'] > (1.5 * df['body_size'])) & df['is_bearish']
        df['lower_rejection'] = (df['lower_wick'] > (1.5 * df['body_size'])) & df['is_bullish']
        
    def detect_all(self, df: pd.DataFrame, lookback: int = 5) -> Dict[str, List[int]]:
        """
        Detect all trend points in the data.
        
        Args:
            df: DataFrame with OHLC data
            lookback: Number of bars to look back for feature calculations
            
        Returns:
            Dict mapping trend types to lists of bar indices
        """
        if not self.detectors:
            logger.warning("No detectors loaded. Use load_detector() first.")
            return {}
            
        # Prepare data with required features
        prepared_df = self.prepare_data(df)
        
        results = {}
        
        # Apply each detector
        for trend_type, detector in self.detectors.items():
            detected_indices = []
            
            for idx in range(lookback, len(prepared_df)):
                if detector(prepared_df, idx, lookback):
                    detected_indices.append(idx)
                    
            results[trend_type] = detected_indices
            logger.info(f"Detected {len(detected_indices)} {trend_type} points")
            
        return results
        
    def detect_type(self, df: pd.DataFrame, trend_type: str, lookback: int = 5) -> List[int]:
        """
        Detect trend points of a specific type in the data.
        
        Args:
            df: DataFrame with OHLC data
            trend_type: Type of trend to detect
            lookback: Number of bars to look back for feature calculations
            
        Returns:
            List of bar indices where the trend type was detected
        """
        if trend_type not in self.detectors:
            logger.warning(f"No detector loaded for {trend_type}")
            return []
            
        # Prepare data with required features
        prepared_df = self.prepare_data(df)
        
        detector = self.detectors[trend_type]
        detected_indices = []
        
        for idx in range(lookback, len(prepared_df)):
            if detector(prepared_df, idx, lookback):
                detected_indices.append(idx)
                
        logger.info(f"Detected {len(detected_indices)} {trend_type} points")
        return detected_indices
        
    def apply_to_live_data(self, df: pd.DataFrame, trend_type: str) -> bool:
        """
        Apply detector to the most recent bar in live data.
        
        Args:
            df: DataFrame with OHLC data (most recent bar at the end)
            trend_type: Type of trend to detect
            
        Returns:
            True if the trend was detected in the most recent bar, False otherwise
        """
        if trend_type not in self.detectors:
            logger.warning(f"No detector loaded for {trend_type}")
            return False
            
        # Get index of most recent complete bar
        most_recent_idx = len(df) - 1
        if most_recent_idx < 5:  # Need at least 5 bars for lookback
            return False
            
        # Prepare data with required features
        prepared_df = self.prepare_data(df)
        
        # Apply detector to most recent bar
        detector = self.detectors[trend_type]
        return detector(prepared_df, most_recent_idx, 5)

# Example usage
if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    
    # Example of how to use the detector
    detector = ImprovedTrendDetector()
    print("This is an example placeholder - use the actual API in your code") 