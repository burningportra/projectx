import {
  IStrategy,
  StrategyResult,
  BaseStrategyConfig
} from '../types/strategy';

import {
  BacktestBarData,
  SubBarData,
  StrategySignal,
  SimulatedTrade,
  Order,
  StrategyConfig,
  OrderStatus,
  OrderType,
  OrderSide,
  UTCTimestamp,
  BacktestResults,
  TradeType
} from '../types/backtester';

/**
 * Abstract base class that implements common functionality for all strategies.
 * Provides default implementations for many IStrategy methods while leaving
 * strategy-specific logic to be implemented by derived classes.
 */
export abstract class BaseStrategy implements IStrategy {
  // Configuration
  protected config: BaseStrategyConfig;

  // State tracking
  protected signals: StrategySignal[] = [];
  protected trades: SimulatedTrade[] = [];
  protected openTrade: SimulatedTrade | null = null;
  protected indicators: Record<string, number> = {};
  
  // Order management
  protected pendingOrders: Order[] = [];
  protected filledOrders: Order[] = [];
  protected cancelledOrders: Order[] = [];
  
  // Counter for generating unique IDs
  private nextOrderId = 1;
  private nextTradeId = 1;

  /**
   * Constructor for BaseStrategy
   * @param config - Strategy configuration options
   */
  constructor(config?: Partial<BaseStrategyConfig>) {
    // Set default configuration values
    this.config = {
      name: this.getName(),
      description: this.getDescription(),
      version: this.getVersion(),
      commission: 0,
      positionSize: 1,
      ...config
    };
  }

  /**
   * Reset strategy state to initial conditions
   */
  reset(): void {
    this.signals = [];
    this.trades = [];
    this.openTrade = null;
    this.indicators = {};
    this.pendingOrders = [];
    this.filledOrders = [];
    this.cancelledOrders = [];
    this.nextOrderId = 1;
    this.nextTradeId = 1;
    
    // Call strategy-specific reset implementation
    this.onReset();
  }

  /**
   * Hook for strategy-specific reset logic
   * Override this method in derived classes to reset strategy-specific state
   */
  protected onReset(): void {
    // Default implementation does nothing
  }

  /**
   * Process a single bar and generate trading signals/actions
   * This is the main method that strategies must implement
   */
  abstract processBar(
    mainBar: BacktestBarData,
    subBars: SubBarData[] | undefined,
    barIndex: number,
    allMainBars: BacktestBarData[]
  ): Promise<StrategyResult> | StrategyResult;

  /**
   * Get all completed trades
   */
  getTrades(): SimulatedTrade[] {
    return this.trades;
  }

  /**
   * Get currently open trade (if any)
   */
  getOpenTrade(): SimulatedTrade | null {
    return this.openTrade;
  }

  /**
   * Get all signals generated by the strategy
   */
  getSignals(): StrategySignal[] {
    return this.signals;
  }

  /**
   * Get current indicator values
   */
  getCurrentIndicators(): Record<string, number> | null {
    return Object.keys(this.indicators).length > 0 ? this.indicators : null;
  }

  /**
   * Get all pending orders
   * @param contractId - Optional contract ID to filter orders
   */
  getPendingOrders(contractId?: string): Order[] {
    if (contractId) {
      return this.pendingOrders.filter(order => order.contractId === contractId);
    }
    return this.pendingOrders;
  }

  /**
   * Get all filled orders
   * @param contractId - Optional contract ID to filter orders
   */
  getFilledOrders(contractId?: string): Order[] {
    if (contractId) {
      return this.filledOrders.filter(order => order.contractId === contractId);
    }
    return this.filledOrders;
  }

  /**
   * Get all cancelled orders
   * @param contractId - Optional contract ID to filter orders
   */
  getCancelledOrders(contractId?: string): Order[] {
    if (contractId) {
      return this.cancelledOrders.filter(order => order.contractId === contractId);
    }
    return this.cancelledOrders;
  }

  /**
   * Update strategy configuration
   * @param config - Partial configuration to merge with current config
   */
  updateConfig(config: Partial<StrategyConfig>): void {
    this.config = {
      ...this.config,
      ...config
    };
    
    // Allow derived classes to react to configuration changes
    this.onConfigUpdated();
  }

  /**
   * Hook for strategy-specific configuration update logic
   * Override this method in derived classes to handle configuration changes
   */
  protected onConfigUpdated(): void {
    // Default implementation does nothing
  }

  /**
   * Get current strategy configuration
   */
  getConfig(): StrategyConfig {
    return this.config;
  }

  /**
   * Get strategy name - abstract method that must be implemented by subclasses
   */
  abstract getName(): string;

  /**
   * Get strategy description - abstract method that must be implemented by subclasses
   */
  abstract getDescription(): string;

  /**
   * Get strategy version - abstract method that must be implemented by subclasses
   */
  abstract getVersion(): string;

  /**
   * Run a complete backtest on historical data
   * Default implementation processes bars sequentially
   */
  backtest(mainBars: BacktestBarData[], subBars?: SubBarData[]): BacktestResults {
    // Reset strategy state before starting backtest
    this.reset();
    
    // Map to organize sub-bars by parent bar index if provided
    const subBarsByParentIndex: Map<number, SubBarData[]> = new Map();
    
    if (subBars && subBars.length > 0) {
      // Group sub-bars by parent bar index
      subBars.forEach(subBar => {
        const parentIndex = subBar.parentBarIndex;
        if (!subBarsByParentIndex.has(parentIndex)) {
          subBarsByParentIndex.set(parentIndex, []);
        }
        subBarsByParentIndex.get(parentIndex)?.push(subBar);
      });
    }
    
    // Process each bar in sequence
    for (let i = 0; i < mainBars.length; i++) {
      const currentSubBars = subBarsByParentIndex.get(i);
      this.processBar(mainBars[i], currentSubBars, i, mainBars);
    }
    
    // Calculate backtest results
    return this.calculateBacktestResults();
  }

  /**
   * Calculate backtest performance metrics
   */
  protected calculateBacktestResults(): BacktestResults {
    const closedTrades = this.trades.filter(trade => trade.status === 'CLOSED');
    
    // Calculate total profit/loss
    const totalProfitOrLoss = closedTrades.reduce(
      (sum, trade) => sum + (trade.profitOrLoss || 0),
      0
    );
    
    // Calculate win rate
    const winningTrades = closedTrades.filter(trade => (trade.profitOrLoss || 0) > 0);
    const winRate = closedTrades.length > 0 
      ? (winningTrades.length / closedTrades.length) * 100 
      : 0;
    
    // Calculate profit factor (sum of winning trades / sum of losing trades)
    const totalWinnings = winningTrades.reduce(
      (sum, trade) => sum + (trade.profitOrLoss || 0),
      0
    );
    
    const losingTrades = closedTrades.filter(trade => (trade.profitOrLoss || 0) < 0);
    const totalLosses = losingTrades.reduce(
      (sum, trade) => sum + Math.abs(trade.profitOrLoss || 0),
      0
    );
    
    const profitFactor = totalLosses > 0 ? totalWinnings / totalLosses : totalWinnings > 0 ? Infinity : 0;
    
    // Calculate max drawdown
    let maxDrawdown = 0;
    let peak = 0;
    let runningTotal = 0;
    
    closedTrades.forEach(trade => {
      runningTotal += (trade.profitOrLoss || 0);
      if (runningTotal > peak) {
        peak = runningTotal;
      }
      const drawdown = peak - runningTotal;
      if (drawdown > maxDrawdown) {
        maxDrawdown = drawdown;
      }
    });
    
    return {
      totalProfitOrLoss,
      winRate,
      totalTrades: closedTrades.length,
      maxDrawdown,
      profitFactor,
      trades: [...this.trades] // Return a copy of trades array
    };
  }

  /**
   * Create a new market order
   * @param side - Buy or sell
   * @param quantity - Number of contracts/shares
   * @param bar - Current price bar
   * @param tradeId - Optional trade ID to associate with this order
   * @param contractId - Optional contract ID
   * @returns The created order
   */
  protected createMarketOrder(
    side: OrderSide,
    quantity: number,
    bar: BacktestBarData,
    tradeId?: string,
    contractId?: string
  ): Order {
    const order: Order = {
      id: this.generateOrderId(),
      type: OrderType.MARKET,
      side,
      quantity,
      status: OrderStatus.PENDING,
      submittedTime: bar.time,
      tradeId,
      contractId,
      message: "Market order created"
    };
    
    this.pendingOrders.push(order);
    return order;
  }

  /**
   * Create a new limit order
   * @param side - Buy or sell
   * @param quantity - Number of contracts/shares
   * @param price - Limit price
   * @param bar - Current price bar
   * @param tradeId - Optional trade ID to associate with this order
   * @param contractId - Optional contract ID
   * @returns The created order
   */
  protected createLimitOrder(
    side: OrderSide,
    quantity: number,
    price: number,
    bar: BacktestBarData,
    tradeId?: string,
    contractId?: string
  ): Order {
    const order: Order = {
      id: this.generateOrderId(),
      type: OrderType.LIMIT,
      side,
      quantity,
      price,
      status: OrderStatus.PENDING,
      submittedTime: bar.time,
      tradeId,
      contractId,
      message: "Limit order created"
    };
    
    this.pendingOrders.push(order);
    return order;
  }

  /**
   * Create a new stop order
   * @param side - Buy or sell
   * @param quantity - Number of contracts/shares
   * @param stopPrice - Stop price to trigger order
   * @param bar - Current price bar
   * @param tradeId - Optional trade ID to associate with this order
   * @param contractId - Optional contract ID
   * @param isStopLoss - Whether this is a stop loss order
   * @returns The created order
   */
  protected createStopOrder(
    side: OrderSide,
    quantity: number,
    stopPrice: number,
    bar: BacktestBarData,
    tradeId?: string,
    contractId?: string,
    isStopLoss: boolean = false
  ): Order {
    const order: Order = {
      id: this.generateOrderId(),
      type: OrderType.STOP,
      side,
      quantity,
      stopPrice,
      status: OrderStatus.PENDING,
      submittedTime: bar.time,
      tradeId,
      contractId,
      isStopLoss,
      message: isStopLoss ? "Stop loss order created" : "Stop order created"
    };
    
    this.pendingOrders.push(order);
    return order;
  }

  /**
   * Create a new take profit order (limit order)
   * @param side - Buy or sell
   * @param quantity - Number of contracts/shares
   * @param price - Take profit price
   * @param bar - Current price bar
   * @param tradeId - Optional trade ID to associate with this order
   * @param contractId - Optional contract ID
   * @returns The created order
   */
  protected createTakeProfitOrder(
    side: OrderSide,
    quantity: number,
    price: number,
    bar: BacktestBarData,
    tradeId?: string,
    contractId?: string
  ): Order {
    const order: Order = {
      id: this.generateOrderId(),
      type: OrderType.LIMIT,
      side,
      quantity,
      price,
      status: OrderStatus.PENDING,
      submittedTime: bar.time,
      tradeId,
      contractId,
      isTakeProfit: true,
      message: "Take profit order created"
    };
    
    this.pendingOrders.push(order);
    return order;
  }

  /**
   * Mark an order as filled
   * @param order - The order to fill
   * @param fillPrice - Price at which the order was filled
   * @param fillTime - Time when the order was filled
   * @returns The filled order
   */
  protected fillOrder(
    order: Order,
    fillPrice: number,
    fillTime: UTCTimestamp
  ): Order {
    // Remove from pending orders
    this.pendingOrders = this.pendingOrders.filter(o => o.id !== order.id);
    
    // Update order details
    order.status = OrderStatus.FILLED;
    order.filledPrice = fillPrice;
    order.filledTime = fillTime;
    order.filledQuantity = order.quantity;
    order.message = "Order filled";
    
    // Calculate commission if configured
    if (this.config.commission) {
      order.commission = fillPrice * order.quantity * this.config.commission / 100;
    }
    
    // Add to filled orders
    this.filledOrders.push(order);
    
    return order;
  }

  /**
   * Cancel an order
   * @param order - The order to cancel
   * @param reason - Reason for cancellation
   * @returns The cancelled order
   */
  protected cancelOrder(order: Order, reason: string): Order {
    // Remove from pending orders
    this.pendingOrders = this.pendingOrders.filter(o => o.id !== order.id);
    
    // Update order details
    order.status = OrderStatus.CANCELLED;
    order.message = reason;
    
    // Add to cancelled orders
    this.cancelledOrders.push(order);
    
    return order;
  }

  /**
   * Create a new trade
   * @param type - Buy or sell
   * @param entryPrice - Entry price
   * @param size - Position size
   * @param entryTime - Entry time
   * @param entryOrder - Order that opened the trade
   * @param entrySignal - Signal that triggered the entry
   * @returns The created trade
   */
  protected createTrade(
    type: TradeType,
    entryPrice: number,
    size: number,
    entryTime: UTCTimestamp,
    entryOrder?: Order,
    entrySignal?: StrategySignal
  ): SimulatedTrade {
    const trade: SimulatedTrade = {
      id: this.generateTradeId(),
      entryTime,
      entryPrice,
      type,
      size,
      status: 'OPEN',
      entryOrder,
      signalEntry: entrySignal
    };
    
    // Store as open trade
    this.openTrade = trade;
    
    return trade;
  }

  /**
   * Close an existing trade
   * @param trade - The trade to close
   * @param exitPrice - Exit price
   * @param exitTime - Exit time
   * @param exitOrder - Order that closed the trade
   * @param exitSignal - Signal that triggered the exit
   * @param exitReason - Reason for closing the trade
   * @returns The closed trade
   */
  protected closeTrade(
    trade: SimulatedTrade,
    exitPrice: number,
    exitTime: UTCTimestamp,
    exitOrder?: Order,
    exitSignal?: StrategySignal,
    exitReason?: 'SIGNAL' | 'STOP_LOSS' | 'TAKE_PROFIT' | 'MANUAL' | 'REVERSAL_EXIT'
  ): SimulatedTrade {
    // Update trade details
    trade.exitPrice = exitPrice;
    trade.exitTime = exitTime;
    trade.status = 'CLOSED';
    trade.exitOrder = exitOrder;
    trade.signalExit = exitSignal;
    trade.exitReason = exitReason;
    
    // Calculate P&L
    const multiplier = trade.type === 'BUY' ? 1 : -1;
    trade.profitOrLoss = multiplier * (exitPrice - trade.entryPrice) * trade.size;
    
    // Subtract commission if configured
    if (trade.commission) {
      trade.profitOrLoss -= trade.commission;
    }
    
    // If this is the currently open trade, clear it
    if (this.openTrade && this.openTrade.id === trade.id) {
      this.openTrade = null;
    }
    
    // Add to completed trades
    this.trades.push(trade);
    
    return trade;
  }

  /**
   * Record a signal generated by the strategy
   * @param signal - The signal to record
   * @returns The recorded signal
   */
  protected recordSignal(signal: StrategySignal): StrategySignal {
    this.signals.push(signal);
    return signal;
  }

  /**
   * Generate a unique order ID
   */
  private generateOrderId(): string {
    return `ord-${this.getName().toLowerCase()}-${this.nextOrderId++}`;
  }

  /**
   * Generate a unique trade ID
   */
  private generateTradeId(): string {
    return `trade-${this.getName().toLowerCase()}-${this.nextTradeId++}`;
  }
}
