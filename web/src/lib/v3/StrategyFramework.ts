import { BacktestBarData, UTCTimestamp, Order, OrderType, OrderSide } from '../types/backtester';
import { BracketOrderConfig } from './BracketOrderSystem';

/**
 * Core strategy context provided to all strategy functions
 */
export interface StrategyContext {
  // Current market data
  currentBar: BacktestBarData;
  currentBarIndex: number;
  currentTime: UTCTimestamp;
  
  // Historical data access
  bars: ReadonlyArray<BacktestBarData>;
  
  // Account information
  accountBalance: number;
  initialBalance: number;
  
  // Position information
  openPositions: ReadonlyArray<StrategyPosition>;
  positionValue: number;
  unrealizedPnL: number;
  
  // Strategy-specific state (immutable)
  strategyState: Readonly<Record<string, any>>;
  
  // Performance metrics
  totalTrades: number;
  winRate: number;
  totalPnL: number;
}

/**
 * Position information visible to strategies
 */
export interface StrategyPosition {
  id: string;
  symbol: string;
  side: OrderSide;
  quantity: number;
  entryPrice: number;
  entryTime: UTCTimestamp;
  currentPrice: number;
  unrealizedPnL: number;
  
  // Associated orders
  stopLossPrice?: number;
  takeProfitPrice?: number;
  hasActiveStopLoss: boolean;
  hasActiveTakeProfit: boolean;
}

/**
 * Indicator values provided to strategies
 */
export interface IndicatorValues {
  [indicatorName: string]: number | number[] | Record<string, number> | any;
}

/**
 * Strategy configuration interface
 */
export interface StrategyConfig {
  [key: string]: string | number | boolean | string[] | number[] | boolean[] | Record<string, unknown> | null;
}

/**
 * Signal types that strategies can emit
 */
export enum StrategySignalType {
  // Entry signals
  BUY = 'BUY',
  SELL = 'SELL',
  
  // Exit signals
  CLOSE_LONG = 'CLOSE_LONG',
  CLOSE_SHORT = 'CLOSE_SHORT',
  CLOSE_ALL = 'CLOSE_ALL',
  
  // Position management
  ADJUST_STOP_LOSS = 'ADJUST_STOP_LOSS',
  ADJUST_TAKE_PROFIT = 'ADJUST_TAKE_PROFIT',
  
  // No action
  HOLD = 'HOLD',
}

/**
 * Action types for strategy execution
 */
export enum StrategyActionType {
  SUBMIT_ORDER = 'SUBMIT_ORDER',
  SUBMIT_BRACKET_ORDER = 'SUBMIT_BRACKET_ORDER',
  CANCEL_ORDER = 'CANCEL_ORDER',
  MODIFY_ORDER = 'MODIFY_ORDER',
  UPDATE_STATE = 'UPDATE_STATE',
  LOG_MESSAGE = 'LOG_MESSAGE',
}

/**
 * Strategy signal with optional metadata
 */
export interface StrategySignal {
  type: StrategySignalType;
  timestamp: UTCTimestamp;
  barIndex: number;
  price?: number;
  confidence?: number; // 0-1 confidence level
  message?: string;
  metadata?: Record<string, unknown>;
}

/**
 * Action that strategies can request
 */
export interface StrategyAction {
  type: StrategyActionType;
  timestamp: UTCTimestamp;
  payload: OrderActionPayload | BracketOrderActionPayload | StateUpdatePayload | LogMessagePayload;
}

/**
 * Order action payload
 */
export interface OrderActionPayload {
  orderType: OrderType;
  side: OrderSide;
  quantity: number;
  price?: number;
  stopPrice?: number;
  symbol: string;
  timeInForce?: string;
  metadata?: Record<string, any>;
}

/**
 * Bracket order action payload
 */
export interface BracketOrderActionPayload extends BracketOrderConfig {
  metadata?: Record<string, any>;
}

/**
 * State update action payload
 */
export interface StateUpdatePayload {
  [key: string]: any;
}

/**
 * Log message action payload
 */
export interface LogMessagePayload {
  level: 'debug' | 'info' | 'warn' | 'error';
  message: string;
  data?: any;
}

/**
 * Result returned by strategy functions
 */
export interface StrategyResult {
  // Signals generated by the strategy
  signals: StrategySignal[];
  
  // Actions to execute
  actions: StrategyAction[];
  
  // State updates (will be merged with existing state)
  stateUpdates: Record<string, any>;
  
  // Debug information
  debug?: {
    reasoning?: string;
    computedValues?: Record<string, any>;
    performance?: Record<string, number>;
  };
}

/**
 * Pure strategy function signature
 */
export type StrategyFunction = (
  context: StrategyContext,
  indicators: IndicatorValues,
  config: StrategyConfig
) => StrategyResult;

/**
 * Strategy metadata and configuration
 */
export interface StrategyDefinition {
  id: string;
  name: string;
  description: string;
  version: string;
  author?: string;
  
  // Strategy function
  execute: StrategyFunction;
  
  // Required indicators
  requiredIndicators: string[];
  
  // Configuration schema
  configSchema: {
    [key: string]: {
      type: 'number' | 'string' | 'boolean' | 'array' | 'object';
      default: any;
      description: string;
      min?: number;
      max?: number;
      options?: any[];
    };
  };
  
  // Default configuration
  defaultConfig: StrategyConfig;
  
  // Risk management defaults
  defaultRiskManagement?: {
    maxPositionSize?: number;
    stopLossPercent?: number;
    takeProfitPercent?: number;
    maxDrawdown?: number;
  };
}

/**
 * Strategy execution context for the engine
 */
export interface StrategyExecutionContext {
  definition: StrategyDefinition;
  config: StrategyConfig;
  isActive: boolean;
  lastExecutionTime?: UTCTimestamp;
  totalExecutions: number;
  averageExecutionTime: number;
  
  // Performance tracking
  signals: StrategySignal[];
  actions: StrategyAction[];
  state: Record<string, any>;
  
  // Error handling
  lastError?: Error;
  errorCount: number;
}

/**
 * Helper functions for creating strategy actions
 */
export class StrategyActions {
  static submitOrder(
    orderType: OrderType,
    side: OrderSide,
    quantity: number,
    price?: number,
    stopPrice?: number,
    metadata?: Record<string, any>
  ): StrategyAction {
    return {
      type: StrategyActionType.SUBMIT_ORDER,
      timestamp: Date.now() as UTCTimestamp,
      payload: {
        orderType,
        side,
        quantity,
        price,
        stopPrice,
        symbol: 'DEFAULT', // Will be set by execution engine
        metadata,
      } as OrderActionPayload,
    };
  }

  static submitBracketOrder(
    side: OrderSide,
    quantity: number,
    entryType: OrderType.MARKET | OrderType.LIMIT,
    entryPrice: number | undefined,
    stopLossPrice: number,
    takeProfitPrice: number,
    metadata?: Record<string, any>
  ): StrategyAction {
    return {
      type: StrategyActionType.SUBMIT_BRACKET_ORDER,
      timestamp: Date.now() as UTCTimestamp,
      payload: {
        symbol: 'DEFAULT', // Will be set by execution engine
        side,
        quantity,
        entryType,
        entryPrice,
        stopLossType: OrderType.STOP,
        stopLossPrice,
        takeProfitType: OrderType.LIMIT,
        takeProfitPrice,
        metadata,
      } as BracketOrderActionPayload,
    };
  }

  static updateState(updates: Record<string, any>): StrategyAction {
    return {
      type: StrategyActionType.UPDATE_STATE,
      timestamp: Date.now() as UTCTimestamp,
      payload: updates as StateUpdatePayload,
    };
  }

  static logMessage(
    level: 'debug' | 'info' | 'warn' | 'error',
    message: string,
    data?: any
  ): StrategyAction {
    return {
      type: StrategyActionType.LOG_MESSAGE,
      timestamp: Date.now() as UTCTimestamp,
      payload: {
        level,
        message,
        data,
      } as LogMessagePayload,
    };
  }
}

/**
 * Helper functions for creating strategy signals
 */
export class StrategySignals {
  static buy(
    price: number,
    confidence: number = 1.0,
    message?: string,
    metadata?: Record<string, unknown>
  ): StrategySignal {
    const signal: StrategySignal = {
      type: StrategySignalType.BUY,
      timestamp: Date.now() as UTCTimestamp,
      barIndex: 0, // Will be set by execution engine
      price,
      confidence,
    };
    if (message !== undefined) signal.message = message;
    if (metadata !== undefined) signal.metadata = metadata;
    return signal;
  }

  static sell(
    price: number,
    confidence: number = 1.0,
    message?: string,
    metadata?: Record<string, any>
  ): StrategySignal {
    return {
      type: StrategySignalType.SELL,
      timestamp: Date.now() as UTCTimestamp,
      barIndex: 0, // Will be set by execution engine
      price,
      confidence,
      message,
      metadata,
    };
  }

  static closeLong(
    price: number,
    confidence: number = 1.0,
    message?: string
  ): StrategySignal {
    return {
      type: StrategySignalType.CLOSE_LONG,
      timestamp: Date.now() as UTCTimestamp,
      barIndex: 0,
      price,
      confidence,
      message,
    };
  }

  static closeShort(
    price: number,
    confidence: number = 1.0,
    message?: string
  ): StrategySignal {
    return {
      type: StrategySignalType.CLOSE_SHORT,
      timestamp: Date.now() as UTCTimestamp,
      barIndex: 0,
      price,
      confidence,
      message,
    };
  }

  static hold(message?: string): StrategySignal {
    return {
      type: StrategySignalType.HOLD,
      timestamp: Date.now() as UTCTimestamp,
      barIndex: 0,
      message,
    };
  }
}

/**
 * Strategy executor that runs pure strategy functions
 */
export class StrategyExecutor {
  private executionContexts = new Map<string, StrategyExecutionContext>();

  /**
   * Register a strategy for execution
   */
  public registerStrategy(
    definition: StrategyDefinition,
    config?: Partial<StrategyConfig>
  ): void {
    const mergedConfig = { ...definition.defaultConfig, ...config };
    
    this.executionContexts.set(definition.id, {
      definition,
      config: mergedConfig,
      isActive: true,
      totalExecutions: 0,
      averageExecutionTime: 0,
      signals: [],
      actions: [],
      state: {},
      errorCount: 0,
    });
  }

  /**
   * Execute a strategy function
   */
  public executeStrategy(
    strategyId: string,
    context: StrategyContext,
    indicators: IndicatorValues
  ): StrategyResult | null {
    const executionContext = this.executionContexts.get(strategyId);
    if (!executionContext || !executionContext.isActive) {
      return null;
    }

    const startTime = performance.now();

    try {
      // Merge strategy state with context
      const contextWithState: StrategyContext = {
        ...context,
        strategyState: executionContext.state,
      };

      // Execute the pure strategy function
      const result = executionContext.definition.execute(
        contextWithState,
        indicators,
        executionContext.config
      );

      // Update execution context
      executionContext.lastExecutionTime = context.currentTime;
      executionContext.totalExecutions++;
      
      const executionTime = performance.now() - startTime;
      executionContext.averageExecutionTime = 
        (executionContext.averageExecutionTime * (executionContext.totalExecutions - 1) + executionTime) /
        executionContext.totalExecutions;

      // Store results
      executionContext.signals.push(...result.signals);
      executionContext.actions.push(...result.actions);
      
      // Update strategy state
      Object.assign(executionContext.state, result.stateUpdates);

      return result;

    } catch (error) {
      executionContext.lastError = error as Error;
      executionContext.errorCount++;
      
      console.error(`Error executing strategy ${strategyId}:`, error);
      return null;
    }
  }

  /**
   * Get strategy execution context
   */
  public getExecutionContext(strategyId: string): StrategyExecutionContext | undefined {
    return this.executionContexts.get(strategyId);
  }

  /**
   * Get all registered strategies
   */
  public getRegisteredStrategies(): StrategyExecutionContext[] {
    return Array.from(this.executionContexts.values());
  }

  /**
   * Activate/deactivate a strategy
   */
  public setStrategyActive(strategyId: string, isActive: boolean): boolean {
    const context = this.executionContexts.get(strategyId);
    if (context) {
      context.isActive = isActive;
      return true;
    }
    return false;
  }

  /**
   * Update strategy configuration
   */
  public updateStrategyConfig(
    strategyId: string,
    configUpdates: Partial<StrategyConfig>
  ): boolean {
    const context = this.executionContexts.get(strategyId);
    if (context) {
      Object.assign(context.config, configUpdates);
      return true;
    }
    return false;
  }

  /**
   * Reset strategy state
   */
  public resetStrategyState(strategyId: string): boolean {
    const context = this.executionContexts.get(strategyId);
    if (context) {
      context.state = {};
      context.signals = [];
      context.actions = [];
      context.totalExecutions = 0;
      context.averageExecutionTime = 0;
      context.errorCount = 0;
      context.lastError = undefined;
      return true;
    }
    return false;
  }

  /**
   * Remove a strategy
   */
  public unregisterStrategy(strategyId: string): boolean {
    return this.executionContexts.delete(strategyId);
  }

  /**
   * Reset all strategies
   */
  public reset(): void {
    this.executionContexts.clear();
  }
}

/**
 * Utility functions for strategy development
 */
export class StrategyUtils {
  /**
   * Check if we have a position in the given direction
   */
  static hasPosition(context: StrategyContext, side?: OrderSide): boolean {
    if (!side) {
      return context.openPositions.length > 0;
    }
    return context.openPositions.some(pos => pos.side === side);
  }

  /**
   * Get position by side
   */
  static getPosition(context: StrategyContext, side: OrderSide): StrategyPosition | undefined {
    return context.openPositions.find(pos => pos.side === side);
  }

  /**
   * Calculate position size based on risk percentage
   */
  static calculatePositionSize(
    accountBalance: number,
    entryPrice: number,
    stopLossPrice: number,
    riskPercent: number
  ): number {
    const riskAmount = accountBalance * (riskPercent / 100);
    const riskPerShare = Math.abs(entryPrice - stopLossPrice);
    return Math.floor(riskAmount / riskPerShare);
  }

  /**
   * Validate strategy result
   */
  static validateResult(result: StrategyResult): boolean {
    // Check for conflicting signals
    const buySignals = result.signals.filter(s => s.type === StrategySignalType.BUY);
    const sellSignals = result.signals.filter(s => s.type === StrategySignalType.SELL);
    
    if (buySignals.length > 0 && sellSignals.length > 0) {
      console.warn('Strategy produced conflicting BUY and SELL signals');
      return false;
    }

    // Check for required fields in actions
    for (const action of result.actions) {
      if (action.type === StrategyActionType.SUBMIT_ORDER) {
        const payload = action.payload as OrderActionPayload;
        if (!payload.orderType || !payload.side || !payload.quantity) {
          console.warn('Invalid order action payload');
          return false;
        }
      }
    }

    return true;
  }
} 